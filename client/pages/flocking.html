<div id="container"></div>
<div id="histogram-vx"></div>
<div id="histogram-vy"></div>
<script>
    /*
    Each agent in this model begins with a random direction, but is constantly shifting its direction to be closer to the average of its closest neighbors. Eventually, all agents will be moving in roughly the same direction.
    */

    const {
        Agent,
        Environment,
        GridEnvironment,
        Histogram,
        ASCIIRenderer,
        CanvasRenderer,
        utils,
        Vector,
        KDTree
    } = flocc;

    /* ------- PARAMETERS --------- */

    const flockSize = 150;
    const width = 600;
    const height = 600;

    /* ---------------------------- */

    /* ------- SET UP ENVIRONMENT, RENDERER --------- */

    const environment = new Environment({
        height,
        width
    });
    const renderer = new CanvasRenderer(environment, { width, height });
    let tree;
    const container = document.getElementById("container");
    renderer.mount(container);

    const histogramVX = new Histogram(environment, {
        buckets: 10,
        height: 200,
        min: -1,
        max: 1,
        width: 800
    });
    histogramVX.mount("#histogram-vx");
    histogramVX.metric("vx");

    const histogramVY = new Histogram(environment, {
        buckets: 10,
        height: 200,
        min: -1,
        max: 1,
        width: 800
    });
    histogramVY.mount("#histogram-vy");
    histogramVY.metric("vy");

    function setup() {
        for (let i = 0; i < flockSize; i++) {
            const agent = new Agent();

            agent.set("x", Math.random() * width);
            agent.set("y", Math.random() * height);

            const angle = 2 * Math.random() * Math.PI;
            agent.set("v", new Vector(Math.cos(angle), Math.sin(angle)));

            agent.set("shape", "arrow");
            agent.set("size", 2.5);

            agent.set("vx", a => a.get("v").x);
            agent.set("vy", a => a.get("v").y);

            agent.addRule(tick);

            environment.addAgent(agent);
        }

        tree = new KDTree(environment.getAgents(), 2);
        environment.use(tree);
        console.log(tree);
    }

    function tick(agent) {
        let { x, y, v } = agent.getData();

        x += v.x;
        y += v.y;

        agent.set("x", x);
        agent.set("y", y);

        // update direction
        var neighbors = tree.agentsWithinDistance(agent, 20);

        if (neighbors.length === 0) return;

        const meanVel = neighbors.reduce(
            (a, b) => a.add(b.get("v")),
            new Vector()
        );
        const norm = utils.distance(meanVel, new Vector());
        meanVel.multiplyScalar(1 / norm);

        v.add(meanVel.multiplyScalar(0.01)).normalize();
    }

    let t = new Date();

    function render() {
        environment.tick();
        // console.log(`${new Date() - t} since last render`);
        t = new Date();
        requestAnimationFrame(render);
    }

    setup();
    render();
</script>
