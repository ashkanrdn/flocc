<div id="container"></div>
<div id="histogram-vx"></div>
<div id="histogram-vy"></div>
<script>
    /*
    Each agent in this model begins with a random direction, but is constantly shifting its direction to be closer to the average of its closest neighbors. Eventually, all agents will be moving in roughly the same direction.
    */

    const {
        Agent,
        Environment,
        GridEnvironment,
        Histogram,
        ASCIIRenderer,
        CanvasRenderer,
        utils,
        Vector,
        KDTree
    } = flocc;
    const { random } = utils;

    /* ------- PARAMETERS --------- */

    const flockSize = 350;
    const width = 600;
    const height = 600;

    /* ---------------------------- */

    /* ------- SET UP ENVIRONMENT, RENDERER --------- */

    const environment = new Environment({
        height,
        width
    });
    const renderer = new CanvasRenderer(environment, { width, height });
    let tree;
    const container = document.getElementById("container");
    renderer.mount(container);

    const histogramVX = new Histogram(environment, {
        buckets: 10,
        height: 200,
        min: -1,
        max: 1,
        width: 800
    });
    histogramVX.mount("#histogram-vx");
    histogramVX.metric("vx");

    const histogramVY = new Histogram(environment, {
        buckets: 10,
        height: 200,
        min: -1,
        max: 1,
        width: 800
    });
    histogramVY.mount("#histogram-vy");
    histogramVY.metric("vy");

    function setup() {
        for (let i = 0; i < flockSize; i++) {
            const agent = new Agent();

            agent.set("p", new Vector(random(0, width), random(0, height)));
            agent.set("x", agent => agent.get("p").x);
            agent.set("y", agent => agent.get("p").y);

            const angle = 2 * Math.random() * Math.PI;
            agent.set("v", new Vector(Math.cos(angle), Math.sin(angle)));

            agent.set("shape", "arrow");
            agent.set("size", 2.5);

            agent.set("vx", a => a.get("v").x);
            agent.set("vy", a => a.get("v").y);

            agent.addRule(tick);

            environment.addAgent(agent);
        }

        tree = new KDTree(environment.getAgents(), 2);
        environment.use(tree);
        console.log(tree);
    }

    function tick(agent) {
        let { p, v } = agent.getData();

        p.x += v.x;
        p.y += v.y;
        if (p.x > width) p.x -= width;
        if (p.x < 0) p.x += width;
        if (p.y > height) p.y -= height;
        if (p.y < 0) p.y += height;

        // update direction
        const d = 30;
        const neighbors = tree.agentsWithinDistance(agent, d);
        if (neighbors.length < 1) return;

        const averageVelocity = new Vector();
        const center = new Vector();
        for (let i = 0; i < neighbors.length; i++) {
            const neighbor = neighbors[i];
            if (neighbor === agent) continue;
            averageVelocity.add(neighbor.get("v"));
            let x = neighbor.get("x");
            let y = neighbor.get("y");
            if (p.x + d > width && x < d) x += width;
            if (p.x - d < 0 && x + d > width) x -= width;
            if (p.y + d > height && y < d) y += height;
            if (p.y - d < 0 && y + d > height) y -= height;
            center.x += x;
            center.y += y;
        }
        center.multiplyScalar(1 / neighbors.length);

        const meanVel = neighbors.reduce(
            (a, b) => a.add(b.get("v")),
            new Vector()
        );
        meanVel.normalize();
        meanVel.multiplyScalar(0.03);

        const towardCenter = p
            .clone()
            .add(center.multiplyScalar(-1))
            .multiplyScalar(0.001);

        v.add(towardCenter);
        v.add(meanVel);
        v.normalize();
    }

    let t = new Date();

    function render() {
        environment.tick();
        // console.log(`${new Date() - t} since last render`);
        t = new Date();
        requestAnimationFrame(render);
    }

    setup();
    render();
</script>
