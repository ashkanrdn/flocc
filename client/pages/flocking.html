<div id="container"></div>
<div id="histogram-vx"></div>
<div id="histogram-vy"></div>
<script>
    /*
    Each agent in this model begins with a random direction, but is constantly shifting its direction to be closer to the average of its closest neighbors. Eventually, all agents will be moving in roughly the same direction.
    */

    const {
        Agent,
        Environment,
        GridEnvironment,
        Histogram,
        ASCIIRenderer,
        CanvasRenderer,
        utils,
        Vector,
        KDTree
    } = flocc;
    const { random } = utils;

    /* ------- PARAMETERS --------- */

    const flockSize = 350;
    const width = 600;
    const height = 600;

    /* ---------------------------- */

    /* ------- SET UP ENVIRONMENT, RENDERER --------- */

    const environment = new Environment({
        height,
        width
    });
    const renderer = new CanvasRenderer(environment, { width, height });
    let tree;
    const container = document.getElementById("container");
    renderer.mount(container);

    function setup() {
        for (let i = 0; i < flockSize; i++) {
            const angle = 2 * Math.random() * Math.PI;
            const agent = new Agent({
                p: new Vector(random(0, width), random(0, height)),
                x: agent => agent.get("p").x,
                y: agent => agent.get("p").y,
                v: new Vector(Math.cos(angle), Math.sin(angle)),
                shape: "arrow",
                size: 2.5,
                vx: a => a.get("v").x,
                vy: a => a.get("v").y
            });

            agent.addRule(tick);

            environment.addAgent(agent);
        }

        tree = new KDTree(environment.getAgents(), 2);
        environment.use(tree);
    }

    function tick(agent) {
        let { p, v } = agent.getData();

        p.x += v.x;
        p.y += v.y;
        if (p.x > width) p.x -= width;
        if (p.x < 0) p.x += width;
        if (p.y > height) p.y -= height;
        if (p.y < 0) p.y += height;

        // update direction
        const d = 30;
        const neighbors = tree.agentsWithinDistance(agent, d);
        if (neighbors.length < 1) return;

        const averageVelocity = new Vector();
        const center = new Vector();
        for (let i = 0; i < neighbors.length; i++) {
            const neighbor = neighbors[i];
            if (neighbor === agent) continue;
            averageVelocity.add(neighbor.get("v"));
            let x = neighbor.get("x");
            let y = neighbor.get("y");
            if (p.x + d > width && x < d) x += width;
            if (p.x - d < 0 && x + d > width) x -= width;
            if (p.y + d > height && y < d) y += height;
            if (p.y - d < 0 && y + d > height) y -= height;
            center.x += x;
            center.y += y;
        }
        center.multiplyScalar(1 / neighbors.length);

        const meanVel = neighbors.reduce(
            (a, b) => a.add(b.get("v")),
            new Vector()
        );
        meanVel.normalize();
        meanVel.multiplyScalar(0.03);

        const towardCenter = p
            .clone()
            .add(center.multiplyScalar(-1))
            .multiplyScalar(0.001);

        v.add(towardCenter);
        v.add(meanVel);
        v.normalize();
    }

    let t = new Date();
    const times = [];

    function render() {
        environment.tick();
        times.push(new Date() - t);
        if (times.length === 10) {
            console.log(utils.mean(times));
            while (times.length > 0) times.pop();
        }
        t = new Date();
        requestAnimationFrame(render);
    }

    setup();
    render();
</script>
